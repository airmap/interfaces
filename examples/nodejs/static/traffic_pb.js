/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var google_protobuf_any_pb = require('google-protobuf/google/protobuf/any_pb.js');
var google_protobuf_duration_pb = require('google-protobuf/google/protobuf/duration_pb.js');
var google_protobuf_timestamp_pb = require('google-protobuf/google/protobuf/timestamp_pb.js');
var extensions_pb = require('./extensions_pb.js');
var measurements_pb = require('./measurements_pb.js');
goog.exportSymbol('proto.airmap.Traffic', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.Callsign', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.Icao', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.Icao.Address24', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.Icao.AircraftType', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.Manufacturer', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.NetworkInterface', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.NetworkInterface.MACAddress', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.ProviderId', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.Registration', null, global);
goog.exportSymbol('proto.airmap.Traffic.Identity.TrackId', null, global);
goog.exportSymbol('proto.airmap.Traffic.Observation', null, global);
goog.exportSymbol('proto.airmap.Traffic.Sensor', null, global);
goog.exportSymbol('proto.airmap.Traffic.Sensor.Adsb', null, global);
goog.exportSymbol('proto.airmap.Traffic.Sensor.Fused', null, global);
goog.exportSymbol('proto.airmap.Traffic.Sensor.PrimaryRadar', null, global);
goog.exportSymbol('proto.airmap.Traffic.Sensor.RadioFrequency', null, global);
goog.exportSymbol('proto.airmap.Traffic.Sensor.SecondaryRadar', null, global);
goog.exportSymbol('proto.airmap.Traffic.Update', null, global);
goog.exportSymbol('proto.airmap.Traffic.Update.FromProvider', null, global);
goog.exportSymbol('proto.airmap.Traffic.Update.ToProvider', null, global);
goog.exportSymbol('proto.airmap.Traffic.Update.ToProvider.Ack', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.displayName = 'proto.airmap.Traffic';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic}
 */
proto.airmap.Traffic.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic;
  return proto.airmap.Traffic.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic}
 */
proto.airmap.Traffic.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Observation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, proto.airmap.Traffic.Observation.repeatedFields_, null);
};
goog.inherits(proto.airmap.Traffic.Observation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Observation.displayName = 'proto.airmap.Traffic.Observation';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.airmap.Traffic.Observation.repeatedFields_ = [2,1024];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Observation.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Observation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Observation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Observation.toObject = function(includeInstance, msg) {
  var f, obj = {
    sensor: (f = msg.getSensor()) && proto.airmap.Traffic.Sensor.toObject(includeInstance, f),
    identitiesList: jspb.Message.toObjectList(msg.getIdentitiesList(),
    proto.airmap.Traffic.Identity.toObject, includeInstance),
    observed: (f = msg.getObserved()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f),
    ttl: (f = msg.getTtl()) && google_protobuf_duration_pb.Duration.toObject(includeInstance, f),
    position: (f = msg.getPosition()) && measurements_pb.Position.toObject(includeInstance, f),
    course: (f = msg.getCourse()) && measurements_pb.Course.toObject(includeInstance, f),
    velocity: (f = msg.getVelocity()) && measurements_pb.Velocity.toObject(includeInstance, f),
    orientation: (f = msg.getOrientation()) && measurements_pb.Orientation.toObject(includeInstance, f),
    detailsList: jspb.Message.toObjectList(msg.getDetailsList(),
    google_protobuf_any_pb.Any.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Observation}
 */
proto.airmap.Traffic.Observation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Observation;
  return proto.airmap.Traffic.Observation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Observation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Observation}
 */
proto.airmap.Traffic.Observation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Sensor;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.deserializeBinaryFromReader);
      msg.setSensor(value);
      break;
    case 2:
      var value = new proto.airmap.Traffic.Identity;
      reader.readMessage(value,proto.airmap.Traffic.Identity.deserializeBinaryFromReader);
      msg.addIdentities(value);
      break;
    case 3:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setObserved(value);
      break;
    case 4:
      var value = new google_protobuf_duration_pb.Duration;
      reader.readMessage(value,google_protobuf_duration_pb.Duration.deserializeBinaryFromReader);
      msg.setTtl(value);
      break;
    case 5:
      var value = new measurements_pb.Position;
      reader.readMessage(value,measurements_pb.Position.deserializeBinaryFromReader);
      msg.setPosition(value);
      break;
    case 6:
      var value = new measurements_pb.Course;
      reader.readMessage(value,measurements_pb.Course.deserializeBinaryFromReader);
      msg.setCourse(value);
      break;
    case 7:
      var value = new measurements_pb.Velocity;
      reader.readMessage(value,measurements_pb.Velocity.deserializeBinaryFromReader);
      msg.setVelocity(value);
      break;
    case 8:
      var value = new measurements_pb.Orientation;
      reader.readMessage(value,measurements_pb.Orientation.deserializeBinaryFromReader);
      msg.setOrientation(value);
      break;
    case 1024:
      var value = new google_protobuf_any_pb.Any;
      reader.readMessage(value,google_protobuf_any_pb.Any.deserializeBinaryFromReader);
      msg.addDetails(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Observation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Observation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Observation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Observation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSensor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.airmap.Traffic.Sensor.serializeBinaryToWriter
    );
  }
  f = message.getIdentitiesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.airmap.Traffic.Identity.serializeBinaryToWriter
    );
  }
  f = message.getObserved();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
  f = message.getTtl();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      google_protobuf_duration_pb.Duration.serializeBinaryToWriter
    );
  }
  f = message.getPosition();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      measurements_pb.Position.serializeBinaryToWriter
    );
  }
  f = message.getCourse();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      measurements_pb.Course.serializeBinaryToWriter
    );
  }
  f = message.getVelocity();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      measurements_pb.Velocity.serializeBinaryToWriter
    );
  }
  f = message.getOrientation();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      measurements_pb.Orientation.serializeBinaryToWriter
    );
  }
  f = message.getDetailsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1024,
      f,
      google_protobuf_any_pb.Any.serializeBinaryToWriter
    );
  }
};


/**
 * optional Sensor sensor = 1;
 * @return {?proto.airmap.Traffic.Sensor}
 */
proto.airmap.Traffic.Observation.prototype.getSensor = function() {
  return /** @type{?proto.airmap.Traffic.Sensor} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Sensor, 1));
};


/** @param {?proto.airmap.Traffic.Sensor|undefined} value */
proto.airmap.Traffic.Observation.prototype.setSensor = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.airmap.Traffic.Observation.prototype.clearSensor = function() {
  this.setSensor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasSensor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated Identity identities = 2;
 * @return {!Array.<!proto.airmap.Traffic.Identity>}
 */
proto.airmap.Traffic.Observation.prototype.getIdentitiesList = function() {
  return /** @type{!Array.<!proto.airmap.Traffic.Identity>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.airmap.Traffic.Identity, 2));
};


/** @param {!Array.<!proto.airmap.Traffic.Identity>} value */
proto.airmap.Traffic.Observation.prototype.setIdentitiesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.airmap.Traffic.Identity=} opt_value
 * @param {number=} opt_index
 * @return {!proto.airmap.Traffic.Identity}
 */
proto.airmap.Traffic.Observation.prototype.addIdentities = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.airmap.Traffic.Identity, opt_index);
};


proto.airmap.Traffic.Observation.prototype.clearIdentitiesList = function() {
  this.setIdentitiesList([]);
};


/**
 * optional google.protobuf.Timestamp observed = 3;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.airmap.Traffic.Observation.prototype.getObserved = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 3));
};


/** @param {?proto.google.protobuf.Timestamp|undefined} value */
proto.airmap.Traffic.Observation.prototype.setObserved = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.airmap.Traffic.Observation.prototype.clearObserved = function() {
  this.setObserved(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasObserved = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional google.protobuf.Duration ttl = 4;
 * @return {?proto.google.protobuf.Duration}
 */
proto.airmap.Traffic.Observation.prototype.getTtl = function() {
  return /** @type{?proto.google.protobuf.Duration} */ (
    jspb.Message.getWrapperField(this, google_protobuf_duration_pb.Duration, 4));
};


/** @param {?proto.google.protobuf.Duration|undefined} value */
proto.airmap.Traffic.Observation.prototype.setTtl = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.airmap.Traffic.Observation.prototype.clearTtl = function() {
  this.setTtl(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasTtl = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Position position = 5;
 * @return {?proto.airmap.Position}
 */
proto.airmap.Traffic.Observation.prototype.getPosition = function() {
  return /** @type{?proto.airmap.Position} */ (
    jspb.Message.getWrapperField(this, measurements_pb.Position, 5));
};


/** @param {?proto.airmap.Position|undefined} value */
proto.airmap.Traffic.Observation.prototype.setPosition = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.airmap.Traffic.Observation.prototype.clearPosition = function() {
  this.setPosition(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasPosition = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Course course = 6;
 * @return {?proto.airmap.Course}
 */
proto.airmap.Traffic.Observation.prototype.getCourse = function() {
  return /** @type{?proto.airmap.Course} */ (
    jspb.Message.getWrapperField(this, measurements_pb.Course, 6));
};


/** @param {?proto.airmap.Course|undefined} value */
proto.airmap.Traffic.Observation.prototype.setCourse = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.airmap.Traffic.Observation.prototype.clearCourse = function() {
  this.setCourse(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasCourse = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional Velocity velocity = 7;
 * @return {?proto.airmap.Velocity}
 */
proto.airmap.Traffic.Observation.prototype.getVelocity = function() {
  return /** @type{?proto.airmap.Velocity} */ (
    jspb.Message.getWrapperField(this, measurements_pb.Velocity, 7));
};


/** @param {?proto.airmap.Velocity|undefined} value */
proto.airmap.Traffic.Observation.prototype.setVelocity = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


proto.airmap.Traffic.Observation.prototype.clearVelocity = function() {
  this.setVelocity(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasVelocity = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional Orientation orientation = 8;
 * @return {?proto.airmap.Orientation}
 */
proto.airmap.Traffic.Observation.prototype.getOrientation = function() {
  return /** @type{?proto.airmap.Orientation} */ (
    jspb.Message.getWrapperField(this, measurements_pb.Orientation, 8));
};


/** @param {?proto.airmap.Orientation|undefined} value */
proto.airmap.Traffic.Observation.prototype.setOrientation = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.airmap.Traffic.Observation.prototype.clearOrientation = function() {
  this.setOrientation(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Observation.prototype.hasOrientation = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * repeated google.protobuf.Any details = 1024;
 * @return {!Array.<!proto.google.protobuf.Any>}
 */
proto.airmap.Traffic.Observation.prototype.getDetailsList = function() {
  return /** @type{!Array.<!proto.google.protobuf.Any>} */ (
    jspb.Message.getRepeatedWrapperField(this, google_protobuf_any_pb.Any, 1024));
};


/** @param {!Array.<!proto.google.protobuf.Any>} value */
proto.airmap.Traffic.Observation.prototype.setDetailsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1024, value);
};


/**
 * @param {!proto.google.protobuf.Any=} opt_value
 * @param {number=} opt_index
 * @return {!proto.google.protobuf.Any}
 */
proto.airmap.Traffic.Observation.prototype.addDetails = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1024, opt_value, proto.google.protobuf.Any, opt_index);
};


proto.airmap.Traffic.Observation.prototype.clearDetailsList = function() {
  this.setDetailsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Sensor = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.airmap.Traffic.Sensor.oneofGroups_);
};
goog.inherits(proto.airmap.Traffic.Sensor, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Sensor.displayName = 'proto.airmap.Traffic.Sensor';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.airmap.Traffic.Sensor.oneofGroups_ = [[1,2,3,4,5]];

/**
 * @enum {number}
 */
proto.airmap.Traffic.Sensor.DetailsCase = {
  DETAILS_NOT_SET: 0,
  FUSED: 1,
  PRIMARY_RADAR: 2,
  SECONDARY_RADAR: 3,
  ADSB: 4,
  RADIO_FREQUENCY: 5
};

/**
 * @return {proto.airmap.Traffic.Sensor.DetailsCase}
 */
proto.airmap.Traffic.Sensor.prototype.getDetailsCase = function() {
  return /** @type {proto.airmap.Traffic.Sensor.DetailsCase} */(jspb.Message.computeOneofCase(this, proto.airmap.Traffic.Sensor.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Sensor.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Sensor.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Sensor} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.toObject = function(includeInstance, msg) {
  var f, obj = {
    fused: (f = msg.getFused()) && proto.airmap.Traffic.Sensor.Fused.toObject(includeInstance, f),
    primaryRadar: (f = msg.getPrimaryRadar()) && proto.airmap.Traffic.Sensor.PrimaryRadar.toObject(includeInstance, f),
    secondaryRadar: (f = msg.getSecondaryRadar()) && proto.airmap.Traffic.Sensor.SecondaryRadar.toObject(includeInstance, f),
    adsb: (f = msg.getAdsb()) && proto.airmap.Traffic.Sensor.Adsb.toObject(includeInstance, f),
    radioFrequency: (f = msg.getRadioFrequency()) && proto.airmap.Traffic.Sensor.RadioFrequency.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Sensor}
 */
proto.airmap.Traffic.Sensor.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Sensor;
  return proto.airmap.Traffic.Sensor.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Sensor} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Sensor}
 */
proto.airmap.Traffic.Sensor.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Sensor.Fused;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.Fused.deserializeBinaryFromReader);
      msg.setFused(value);
      break;
    case 2:
      var value = new proto.airmap.Traffic.Sensor.PrimaryRadar;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.PrimaryRadar.deserializeBinaryFromReader);
      msg.setPrimaryRadar(value);
      break;
    case 3:
      var value = new proto.airmap.Traffic.Sensor.SecondaryRadar;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.SecondaryRadar.deserializeBinaryFromReader);
      msg.setSecondaryRadar(value);
      break;
    case 4:
      var value = new proto.airmap.Traffic.Sensor.Adsb;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.Adsb.deserializeBinaryFromReader);
      msg.setAdsb(value);
      break;
    case 5:
      var value = new proto.airmap.Traffic.Sensor.RadioFrequency;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.RadioFrequency.deserializeBinaryFromReader);
      msg.setRadioFrequency(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Sensor.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Sensor.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Sensor} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getFused();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.airmap.Traffic.Sensor.Fused.serializeBinaryToWriter
    );
  }
  f = message.getPrimaryRadar();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.airmap.Traffic.Sensor.PrimaryRadar.serializeBinaryToWriter
    );
  }
  f = message.getSecondaryRadar();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.airmap.Traffic.Sensor.SecondaryRadar.serializeBinaryToWriter
    );
  }
  f = message.getAdsb();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.airmap.Traffic.Sensor.Adsb.serializeBinaryToWriter
    );
  }
  f = message.getRadioFrequency();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.airmap.Traffic.Sensor.RadioFrequency.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Sensor.Fused = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.airmap.Traffic.Sensor.Fused.repeatedFields_, null);
};
goog.inherits(proto.airmap.Traffic.Sensor.Fused, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Sensor.Fused.displayName = 'proto.airmap.Traffic.Sensor.Fused';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.airmap.Traffic.Sensor.Fused.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Sensor.Fused.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Sensor.Fused.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Sensor.Fused} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.Fused.toObject = function(includeInstance, msg) {
  var f, obj = {
    sensorsList: jspb.Message.toObjectList(msg.getSensorsList(),
    proto.airmap.Traffic.Sensor.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Sensor.Fused}
 */
proto.airmap.Traffic.Sensor.Fused.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Sensor.Fused;
  return proto.airmap.Traffic.Sensor.Fused.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Sensor.Fused} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Sensor.Fused}
 */
proto.airmap.Traffic.Sensor.Fused.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Sensor;
      reader.readMessage(value,proto.airmap.Traffic.Sensor.deserializeBinaryFromReader);
      msg.addSensors(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Sensor.Fused.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Sensor.Fused.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Sensor.Fused} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.Fused.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSensorsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.airmap.Traffic.Sensor.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Sensor sensors = 1;
 * @return {!Array.<!proto.airmap.Traffic.Sensor>}
 */
proto.airmap.Traffic.Sensor.Fused.prototype.getSensorsList = function() {
  return /** @type{!Array.<!proto.airmap.Traffic.Sensor>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.airmap.Traffic.Sensor, 1));
};


/** @param {!Array.<!proto.airmap.Traffic.Sensor>} value */
proto.airmap.Traffic.Sensor.Fused.prototype.setSensorsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.airmap.Traffic.Sensor=} opt_value
 * @param {number=} opt_index
 * @return {!proto.airmap.Traffic.Sensor}
 */
proto.airmap.Traffic.Sensor.Fused.prototype.addSensors = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.airmap.Traffic.Sensor, opt_index);
};


proto.airmap.Traffic.Sensor.Fused.prototype.clearSensorsList = function() {
  this.setSensorsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Sensor.PrimaryRadar = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Sensor.PrimaryRadar, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Sensor.PrimaryRadar.displayName = 'proto.airmap.Traffic.Sensor.PrimaryRadar';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Sensor.PrimaryRadar.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Sensor.PrimaryRadar.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Sensor.PrimaryRadar} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.PrimaryRadar.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Sensor.PrimaryRadar}
 */
proto.airmap.Traffic.Sensor.PrimaryRadar.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Sensor.PrimaryRadar;
  return proto.airmap.Traffic.Sensor.PrimaryRadar.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Sensor.PrimaryRadar} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Sensor.PrimaryRadar}
 */
proto.airmap.Traffic.Sensor.PrimaryRadar.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Sensor.PrimaryRadar.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Sensor.PrimaryRadar.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Sensor.PrimaryRadar} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.PrimaryRadar.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Sensor.SecondaryRadar = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Sensor.SecondaryRadar, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Sensor.SecondaryRadar.displayName = 'proto.airmap.Traffic.Sensor.SecondaryRadar';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Sensor.SecondaryRadar.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Sensor.SecondaryRadar.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Sensor.SecondaryRadar} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.SecondaryRadar.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Sensor.SecondaryRadar}
 */
proto.airmap.Traffic.Sensor.SecondaryRadar.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Sensor.SecondaryRadar;
  return proto.airmap.Traffic.Sensor.SecondaryRadar.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Sensor.SecondaryRadar} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Sensor.SecondaryRadar}
 */
proto.airmap.Traffic.Sensor.SecondaryRadar.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Sensor.SecondaryRadar.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Sensor.SecondaryRadar.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Sensor.SecondaryRadar} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.SecondaryRadar.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Sensor.Adsb = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Sensor.Adsb, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Sensor.Adsb.displayName = 'proto.airmap.Traffic.Sensor.Adsb';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Sensor.Adsb.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Sensor.Adsb.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Sensor.Adsb} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.Adsb.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Sensor.Adsb}
 */
proto.airmap.Traffic.Sensor.Adsb.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Sensor.Adsb;
  return proto.airmap.Traffic.Sensor.Adsb.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Sensor.Adsb} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Sensor.Adsb}
 */
proto.airmap.Traffic.Sensor.Adsb.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Sensor.Adsb.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Sensor.Adsb.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Sensor.Adsb} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.Adsb.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Sensor.RadioFrequency = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Sensor.RadioFrequency, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Sensor.RadioFrequency.displayName = 'proto.airmap.Traffic.Sensor.RadioFrequency';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Sensor.RadioFrequency.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Sensor.RadioFrequency.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Sensor.RadioFrequency} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.RadioFrequency.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Sensor.RadioFrequency}
 */
proto.airmap.Traffic.Sensor.RadioFrequency.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Sensor.RadioFrequency;
  return proto.airmap.Traffic.Sensor.RadioFrequency.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Sensor.RadioFrequency} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Sensor.RadioFrequency}
 */
proto.airmap.Traffic.Sensor.RadioFrequency.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Sensor.RadioFrequency.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Sensor.RadioFrequency.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Sensor.RadioFrequency} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Sensor.RadioFrequency.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};


/**
 * optional Fused fused = 1;
 * @return {?proto.airmap.Traffic.Sensor.Fused}
 */
proto.airmap.Traffic.Sensor.prototype.getFused = function() {
  return /** @type{?proto.airmap.Traffic.Sensor.Fused} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Sensor.Fused, 1));
};


/** @param {?proto.airmap.Traffic.Sensor.Fused|undefined} value */
proto.airmap.Traffic.Sensor.prototype.setFused = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.airmap.Traffic.Sensor.oneofGroups_[0], value);
};


proto.airmap.Traffic.Sensor.prototype.clearFused = function() {
  this.setFused(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Sensor.prototype.hasFused = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional PrimaryRadar primary_radar = 2;
 * @return {?proto.airmap.Traffic.Sensor.PrimaryRadar}
 */
proto.airmap.Traffic.Sensor.prototype.getPrimaryRadar = function() {
  return /** @type{?proto.airmap.Traffic.Sensor.PrimaryRadar} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Sensor.PrimaryRadar, 2));
};


/** @param {?proto.airmap.Traffic.Sensor.PrimaryRadar|undefined} value */
proto.airmap.Traffic.Sensor.prototype.setPrimaryRadar = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.airmap.Traffic.Sensor.oneofGroups_[0], value);
};


proto.airmap.Traffic.Sensor.prototype.clearPrimaryRadar = function() {
  this.setPrimaryRadar(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Sensor.prototype.hasPrimaryRadar = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional SecondaryRadar secondary_radar = 3;
 * @return {?proto.airmap.Traffic.Sensor.SecondaryRadar}
 */
proto.airmap.Traffic.Sensor.prototype.getSecondaryRadar = function() {
  return /** @type{?proto.airmap.Traffic.Sensor.SecondaryRadar} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Sensor.SecondaryRadar, 3));
};


/** @param {?proto.airmap.Traffic.Sensor.SecondaryRadar|undefined} value */
proto.airmap.Traffic.Sensor.prototype.setSecondaryRadar = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.airmap.Traffic.Sensor.oneofGroups_[0], value);
};


proto.airmap.Traffic.Sensor.prototype.clearSecondaryRadar = function() {
  this.setSecondaryRadar(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Sensor.prototype.hasSecondaryRadar = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Adsb adsb = 4;
 * @return {?proto.airmap.Traffic.Sensor.Adsb}
 */
proto.airmap.Traffic.Sensor.prototype.getAdsb = function() {
  return /** @type{?proto.airmap.Traffic.Sensor.Adsb} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Sensor.Adsb, 4));
};


/** @param {?proto.airmap.Traffic.Sensor.Adsb|undefined} value */
proto.airmap.Traffic.Sensor.prototype.setAdsb = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.airmap.Traffic.Sensor.oneofGroups_[0], value);
};


proto.airmap.Traffic.Sensor.prototype.clearAdsb = function() {
  this.setAdsb(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Sensor.prototype.hasAdsb = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RadioFrequency radio_frequency = 5;
 * @return {?proto.airmap.Traffic.Sensor.RadioFrequency}
 */
proto.airmap.Traffic.Sensor.prototype.getRadioFrequency = function() {
  return /** @type{?proto.airmap.Traffic.Sensor.RadioFrequency} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Sensor.RadioFrequency, 5));
};


/** @param {?proto.airmap.Traffic.Sensor.RadioFrequency|undefined} value */
proto.airmap.Traffic.Sensor.prototype.setRadioFrequency = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.airmap.Traffic.Sensor.oneofGroups_[0], value);
};


proto.airmap.Traffic.Sensor.prototype.clearRadioFrequency = function() {
  this.setRadioFrequency(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Sensor.prototype.hasRadioFrequency = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.airmap.Traffic.Identity.oneofGroups_);
};
goog.inherits(proto.airmap.Traffic.Identity, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.displayName = 'proto.airmap.Traffic.Identity';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.airmap.Traffic.Identity.oneofGroups_ = [[1,2,3,4,5,6,7]];

/**
 * @enum {number}
 */
proto.airmap.Traffic.Identity.DetailsCase = {
  DETAILS_NOT_SET: 0,
  PROVIDER_ID: 1,
  TRACK_ID: 2,
  CALLSIGN: 3,
  REGISTRATION: 4,
  ICAO: 5,
  MANUFACTURER: 6,
  NETWORK: 7
};

/**
 * @return {proto.airmap.Traffic.Identity.DetailsCase}
 */
proto.airmap.Traffic.Identity.prototype.getDetailsCase = function() {
  return /** @type {proto.airmap.Traffic.Identity.DetailsCase} */(jspb.Message.computeOneofCase(this, proto.airmap.Traffic.Identity.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.toObject = function(includeInstance, msg) {
  var f, obj = {
    providerId: (f = msg.getProviderId()) && proto.airmap.Traffic.Identity.ProviderId.toObject(includeInstance, f),
    trackId: (f = msg.getTrackId()) && proto.airmap.Traffic.Identity.TrackId.toObject(includeInstance, f),
    callsign: (f = msg.getCallsign()) && proto.airmap.Traffic.Identity.Callsign.toObject(includeInstance, f),
    registration: (f = msg.getRegistration()) && proto.airmap.Traffic.Identity.Registration.toObject(includeInstance, f),
    icao: (f = msg.getIcao()) && proto.airmap.Traffic.Identity.Icao.toObject(includeInstance, f),
    manufacturer: (f = msg.getManufacturer()) && proto.airmap.Traffic.Identity.Manufacturer.toObject(includeInstance, f),
    network: (f = msg.getNetwork()) && proto.airmap.Traffic.Identity.NetworkInterface.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity}
 */
proto.airmap.Traffic.Identity.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity;
  return proto.airmap.Traffic.Identity.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity}
 */
proto.airmap.Traffic.Identity.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Identity.ProviderId;
      reader.readMessage(value,proto.airmap.Traffic.Identity.ProviderId.deserializeBinaryFromReader);
      msg.setProviderId(value);
      break;
    case 2:
      var value = new proto.airmap.Traffic.Identity.TrackId;
      reader.readMessage(value,proto.airmap.Traffic.Identity.TrackId.deserializeBinaryFromReader);
      msg.setTrackId(value);
      break;
    case 3:
      var value = new proto.airmap.Traffic.Identity.Callsign;
      reader.readMessage(value,proto.airmap.Traffic.Identity.Callsign.deserializeBinaryFromReader);
      msg.setCallsign(value);
      break;
    case 4:
      var value = new proto.airmap.Traffic.Identity.Registration;
      reader.readMessage(value,proto.airmap.Traffic.Identity.Registration.deserializeBinaryFromReader);
      msg.setRegistration(value);
      break;
    case 5:
      var value = new proto.airmap.Traffic.Identity.Icao;
      reader.readMessage(value,proto.airmap.Traffic.Identity.Icao.deserializeBinaryFromReader);
      msg.setIcao(value);
      break;
    case 6:
      var value = new proto.airmap.Traffic.Identity.Manufacturer;
      reader.readMessage(value,proto.airmap.Traffic.Identity.Manufacturer.deserializeBinaryFromReader);
      msg.setManufacturer(value);
      break;
    case 7:
      var value = new proto.airmap.Traffic.Identity.NetworkInterface;
      reader.readMessage(value,proto.airmap.Traffic.Identity.NetworkInterface.deserializeBinaryFromReader);
      msg.setNetwork(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProviderId();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.airmap.Traffic.Identity.ProviderId.serializeBinaryToWriter
    );
  }
  f = message.getTrackId();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.airmap.Traffic.Identity.TrackId.serializeBinaryToWriter
    );
  }
  f = message.getCallsign();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.airmap.Traffic.Identity.Callsign.serializeBinaryToWriter
    );
  }
  f = message.getRegistration();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.airmap.Traffic.Identity.Registration.serializeBinaryToWriter
    );
  }
  f = message.getIcao();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.airmap.Traffic.Identity.Icao.serializeBinaryToWriter
    );
  }
  f = message.getManufacturer();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.airmap.Traffic.Identity.Manufacturer.serializeBinaryToWriter
    );
  }
  f = message.getNetwork();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.airmap.Traffic.Identity.NetworkInterface.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.ProviderId = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.ProviderId, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.ProviderId.displayName = 'proto.airmap.Traffic.Identity.ProviderId';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.ProviderId.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.ProviderId.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.ProviderId} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.ProviderId.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.ProviderId}
 */
proto.airmap.Traffic.Identity.ProviderId.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.ProviderId;
  return proto.airmap.Traffic.Identity.ProviderId.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.ProviderId} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.ProviderId}
 */
proto.airmap.Traffic.Identity.ProviderId.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.ProviderId.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.ProviderId.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.ProviderId} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.ProviderId.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.ProviderId.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.ProviderId.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.TrackId = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.TrackId, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.TrackId.displayName = 'proto.airmap.Traffic.Identity.TrackId';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.TrackId.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.TrackId.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.TrackId} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.TrackId.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.TrackId}
 */
proto.airmap.Traffic.Identity.TrackId.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.TrackId;
  return proto.airmap.Traffic.Identity.TrackId.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.TrackId} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.TrackId}
 */
proto.airmap.Traffic.Identity.TrackId.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.TrackId.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.TrackId.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.TrackId} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.TrackId.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.TrackId.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.TrackId.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.Callsign = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.Callsign, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.Callsign.displayName = 'proto.airmap.Traffic.Identity.Callsign';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.Callsign.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.Callsign.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.Callsign} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Callsign.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.Callsign}
 */
proto.airmap.Traffic.Identity.Callsign.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.Callsign;
  return proto.airmap.Traffic.Identity.Callsign.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.Callsign} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.Callsign}
 */
proto.airmap.Traffic.Identity.Callsign.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.Callsign.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.Callsign.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.Callsign} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Callsign.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Callsign.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Callsign.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.Registration = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.Registration, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.Registration.displayName = 'proto.airmap.Traffic.Identity.Registration';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.Registration.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.Registration.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.Registration} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Registration.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.Registration}
 */
proto.airmap.Traffic.Identity.Registration.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.Registration;
  return proto.airmap.Traffic.Identity.Registration.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.Registration} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.Registration}
 */
proto.airmap.Traffic.Identity.Registration.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.Registration.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.Registration.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.Registration} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Registration.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Registration.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Registration.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.Icao = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.Icao, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.Icao.displayName = 'proto.airmap.Traffic.Identity.Icao';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.Icao.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.Icao.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.Icao} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Icao.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: (f = msg.getAddress()) && proto.airmap.Traffic.Identity.Icao.Address24.toObject(includeInstance, f),
    aircraftType: (f = msg.getAircraftType()) && proto.airmap.Traffic.Identity.Icao.AircraftType.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.Icao}
 */
proto.airmap.Traffic.Identity.Icao.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.Icao;
  return proto.airmap.Traffic.Identity.Icao.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.Icao} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.Icao}
 */
proto.airmap.Traffic.Identity.Icao.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Identity.Icao.Address24;
      reader.readMessage(value,proto.airmap.Traffic.Identity.Icao.Address24.deserializeBinaryFromReader);
      msg.setAddress(value);
      break;
    case 2:
      var value = new proto.airmap.Traffic.Identity.Icao.AircraftType;
      reader.readMessage(value,proto.airmap.Traffic.Identity.Icao.AircraftType.deserializeBinaryFromReader);
      msg.setAircraftType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.Icao.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.Icao.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.Icao} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Icao.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.airmap.Traffic.Identity.Icao.Address24.serializeBinaryToWriter
    );
  }
  f = message.getAircraftType();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.airmap.Traffic.Identity.Icao.AircraftType.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.Icao.Address24 = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.Icao.Address24, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.Icao.Address24.displayName = 'proto.airmap.Traffic.Identity.Icao.Address24';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.Icao.Address24.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.Icao.Address24.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.Icao.Address24} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Icao.Address24.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.Icao.Address24}
 */
proto.airmap.Traffic.Identity.Icao.Address24.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.Icao.Address24;
  return proto.airmap.Traffic.Identity.Icao.Address24.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.Icao.Address24} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.Icao.Address24}
 */
proto.airmap.Traffic.Identity.Icao.Address24.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.Icao.Address24.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.Icao.Address24.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.Icao.Address24} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Icao.Address24.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Icao.Address24.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Icao.Address24.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.Icao.AircraftType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.Icao.AircraftType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.Icao.AircraftType.displayName = 'proto.airmap.Traffic.Identity.Icao.AircraftType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.Icao.AircraftType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.Icao.AircraftType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.Icao.AircraftType}
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.Icao.AircraftType;
  return proto.airmap.Traffic.Identity.Icao.AircraftType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.Icao.AircraftType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.Icao.AircraftType}
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.Icao.AircraftType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.Icao.AircraftType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Icao.AircraftType.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Icao.AircraftType.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional Address24 address = 1;
 * @return {?proto.airmap.Traffic.Identity.Icao.Address24}
 */
proto.airmap.Traffic.Identity.Icao.prototype.getAddress = function() {
  return /** @type{?proto.airmap.Traffic.Identity.Icao.Address24} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.Icao.Address24, 1));
};


/** @param {?proto.airmap.Traffic.Identity.Icao.Address24|undefined} value */
proto.airmap.Traffic.Identity.Icao.prototype.setAddress = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.airmap.Traffic.Identity.Icao.prototype.clearAddress = function() {
  this.setAddress(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.Icao.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional AircraftType aircraft_type = 2;
 * @return {?proto.airmap.Traffic.Identity.Icao.AircraftType}
 */
proto.airmap.Traffic.Identity.Icao.prototype.getAircraftType = function() {
  return /** @type{?proto.airmap.Traffic.Identity.Icao.AircraftType} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.Icao.AircraftType, 2));
};


/** @param {?proto.airmap.Traffic.Identity.Icao.AircraftType|undefined} value */
proto.airmap.Traffic.Identity.Icao.prototype.setAircraftType = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.airmap.Traffic.Identity.Icao.prototype.clearAircraftType = function() {
  this.setAircraftType(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.Icao.prototype.hasAircraftType = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.Manufacturer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.Manufacturer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.Manufacturer.displayName = 'proto.airmap.Traffic.Identity.Manufacturer';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.Manufacturer.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.Manufacturer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.Manufacturer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Manufacturer.toObject = function(includeInstance, msg) {
  var f, obj = {
    make: jspb.Message.getFieldWithDefault(msg, 1, ""),
    model: jspb.Message.getFieldWithDefault(msg, 2, ""),
    serialNumber: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.Manufacturer}
 */
proto.airmap.Traffic.Identity.Manufacturer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.Manufacturer;
  return proto.airmap.Traffic.Identity.Manufacturer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.Manufacturer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.Manufacturer}
 */
proto.airmap.Traffic.Identity.Manufacturer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMake(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setModel(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSerialNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.Manufacturer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.Manufacturer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.Manufacturer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.Manufacturer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMake();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getModel();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSerialNumber();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string make = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Manufacturer.prototype.getMake = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Manufacturer.prototype.setMake = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string model = 2;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Manufacturer.prototype.getModel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Manufacturer.prototype.setModel = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string serial_number = 3;
 * @return {string}
 */
proto.airmap.Traffic.Identity.Manufacturer.prototype.getSerialNumber = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.Manufacturer.prototype.setSerialNumber = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.NetworkInterface = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.NetworkInterface, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.NetworkInterface.displayName = 'proto.airmap.Traffic.Identity.NetworkInterface';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.NetworkInterface.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.NetworkInterface.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.NetworkInterface} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.NetworkInterface.toObject = function(includeInstance, msg) {
  var f, obj = {
    macAddress: (f = msg.getMacAddress()) && proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.NetworkInterface}
 */
proto.airmap.Traffic.Identity.NetworkInterface.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.NetworkInterface;
  return proto.airmap.Traffic.Identity.NetworkInterface.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.NetworkInterface} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.NetworkInterface}
 */
proto.airmap.Traffic.Identity.NetworkInterface.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Identity.NetworkInterface.MACAddress;
      reader.readMessage(value,proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.deserializeBinaryFromReader);
      msg.setMacAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.NetworkInterface.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.NetworkInterface.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.NetworkInterface} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.NetworkInterface.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMacAddress();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Identity.NetworkInterface.MACAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.displayName = 'proto.airmap.Traffic.Identity.NetworkInterface.MACAddress';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Identity.NetworkInterface.MACAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    asString: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Identity.NetworkInterface.MACAddress}
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Identity.NetworkInterface.MACAddress;
  return proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Identity.NetworkInterface.MACAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Identity.NetworkInterface.MACAddress}
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAsString(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Identity.NetworkInterface.MACAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAsString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string as_string = 1;
 * @return {string}
 */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.prototype.getAsString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.airmap.Traffic.Identity.NetworkInterface.MACAddress.prototype.setAsString = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional MACAddress mac_address = 1;
 * @return {?proto.airmap.Traffic.Identity.NetworkInterface.MACAddress}
 */
proto.airmap.Traffic.Identity.NetworkInterface.prototype.getMacAddress = function() {
  return /** @type{?proto.airmap.Traffic.Identity.NetworkInterface.MACAddress} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.NetworkInterface.MACAddress, 1));
};


/** @param {?proto.airmap.Traffic.Identity.NetworkInterface.MACAddress|undefined} value */
proto.airmap.Traffic.Identity.NetworkInterface.prototype.setMacAddress = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.airmap.Traffic.Identity.NetworkInterface.prototype.clearMacAddress = function() {
  this.setMacAddress(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.NetworkInterface.prototype.hasMacAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ProviderId provider_id = 1;
 * @return {?proto.airmap.Traffic.Identity.ProviderId}
 */
proto.airmap.Traffic.Identity.prototype.getProviderId = function() {
  return /** @type{?proto.airmap.Traffic.Identity.ProviderId} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.ProviderId, 1));
};


/** @param {?proto.airmap.Traffic.Identity.ProviderId|undefined} value */
proto.airmap.Traffic.Identity.prototype.setProviderId = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearProviderId = function() {
  this.setProviderId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasProviderId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TrackId track_id = 2;
 * @return {?proto.airmap.Traffic.Identity.TrackId}
 */
proto.airmap.Traffic.Identity.prototype.getTrackId = function() {
  return /** @type{?proto.airmap.Traffic.Identity.TrackId} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.TrackId, 2));
};


/** @param {?proto.airmap.Traffic.Identity.TrackId|undefined} value */
proto.airmap.Traffic.Identity.prototype.setTrackId = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearTrackId = function() {
  this.setTrackId(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasTrackId = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Callsign callsign = 3;
 * @return {?proto.airmap.Traffic.Identity.Callsign}
 */
proto.airmap.Traffic.Identity.prototype.getCallsign = function() {
  return /** @type{?proto.airmap.Traffic.Identity.Callsign} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.Callsign, 3));
};


/** @param {?proto.airmap.Traffic.Identity.Callsign|undefined} value */
proto.airmap.Traffic.Identity.prototype.setCallsign = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearCallsign = function() {
  this.setCallsign(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasCallsign = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Registration registration = 4;
 * @return {?proto.airmap.Traffic.Identity.Registration}
 */
proto.airmap.Traffic.Identity.prototype.getRegistration = function() {
  return /** @type{?proto.airmap.Traffic.Identity.Registration} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.Registration, 4));
};


/** @param {?proto.airmap.Traffic.Identity.Registration|undefined} value */
proto.airmap.Traffic.Identity.prototype.setRegistration = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearRegistration = function() {
  this.setRegistration(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasRegistration = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional Icao icao = 5;
 * @return {?proto.airmap.Traffic.Identity.Icao}
 */
proto.airmap.Traffic.Identity.prototype.getIcao = function() {
  return /** @type{?proto.airmap.Traffic.Identity.Icao} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.Icao, 5));
};


/** @param {?proto.airmap.Traffic.Identity.Icao|undefined} value */
proto.airmap.Traffic.Identity.prototype.setIcao = function(value) {
  jspb.Message.setOneofWrapperField(this, 5, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearIcao = function() {
  this.setIcao(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasIcao = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional Manufacturer manufacturer = 6;
 * @return {?proto.airmap.Traffic.Identity.Manufacturer}
 */
proto.airmap.Traffic.Identity.prototype.getManufacturer = function() {
  return /** @type{?proto.airmap.Traffic.Identity.Manufacturer} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.Manufacturer, 6));
};


/** @param {?proto.airmap.Traffic.Identity.Manufacturer|undefined} value */
proto.airmap.Traffic.Identity.prototype.setManufacturer = function(value) {
  jspb.Message.setOneofWrapperField(this, 6, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearManufacturer = function() {
  this.setManufacturer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasManufacturer = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional NetworkInterface network = 7;
 * @return {?proto.airmap.Traffic.Identity.NetworkInterface}
 */
proto.airmap.Traffic.Identity.prototype.getNetwork = function() {
  return /** @type{?proto.airmap.Traffic.Identity.NetworkInterface} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Identity.NetworkInterface, 7));
};


/** @param {?proto.airmap.Traffic.Identity.NetworkInterface|undefined} value */
proto.airmap.Traffic.Identity.prototype.setNetwork = function(value) {
  jspb.Message.setOneofWrapperField(this, 7, proto.airmap.Traffic.Identity.oneofGroups_[0], value);
};


proto.airmap.Traffic.Identity.prototype.clearNetwork = function() {
  this.setNetwork(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Identity.prototype.hasNetwork = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Update = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Update, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Update.displayName = 'proto.airmap.Traffic.Update';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Update.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Update.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Update} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Update}
 */
proto.airmap.Traffic.Update.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Update;
  return proto.airmap.Traffic.Update.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Update} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Update}
 */
proto.airmap.Traffic.Update.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Update.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Update.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Update} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Update.FromProvider = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.airmap.Traffic.Update.FromProvider.repeatedFields_, null);
};
goog.inherits(proto.airmap.Traffic.Update.FromProvider, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Update.FromProvider.displayName = 'proto.airmap.Traffic.Update.FromProvider';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.airmap.Traffic.Update.FromProvider.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Update.FromProvider.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Update.FromProvider} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.FromProvider.toObject = function(includeInstance, msg) {
  var f, obj = {
    observationsList: jspb.Message.toObjectList(msg.getObservationsList(),
    proto.airmap.Traffic.Observation.toObject, includeInstance),
    submitted: (f = msg.getSubmitted()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f),
    received: (f = msg.getReceived()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Update.FromProvider}
 */
proto.airmap.Traffic.Update.FromProvider.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Update.FromProvider;
  return proto.airmap.Traffic.Update.FromProvider.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Update.FromProvider} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Update.FromProvider}
 */
proto.airmap.Traffic.Update.FromProvider.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Observation;
      reader.readMessage(value,proto.airmap.Traffic.Observation.deserializeBinaryFromReader);
      msg.addObservations(value);
      break;
    case 2:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setSubmitted(value);
      break;
    case 3:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setReceived(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Update.FromProvider.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Update.FromProvider} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.FromProvider.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getObservationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.airmap.Traffic.Observation.serializeBinaryToWriter
    );
  }
  f = message.getSubmitted();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
  f = message.getReceived();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Observation observations = 1;
 * @return {!Array.<!proto.airmap.Traffic.Observation>}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.getObservationsList = function() {
  return /** @type{!Array.<!proto.airmap.Traffic.Observation>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.airmap.Traffic.Observation, 1));
};


/** @param {!Array.<!proto.airmap.Traffic.Observation>} value */
proto.airmap.Traffic.Update.FromProvider.prototype.setObservationsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.airmap.Traffic.Observation=} opt_value
 * @param {number=} opt_index
 * @return {!proto.airmap.Traffic.Observation}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.addObservations = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.airmap.Traffic.Observation, opt_index);
};


proto.airmap.Traffic.Update.FromProvider.prototype.clearObservationsList = function() {
  this.setObservationsList([]);
};


/**
 * optional google.protobuf.Timestamp submitted = 2;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.getSubmitted = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 2));
};


/** @param {?proto.google.protobuf.Timestamp|undefined} value */
proto.airmap.Traffic.Update.FromProvider.prototype.setSubmitted = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.airmap.Traffic.Update.FromProvider.prototype.clearSubmitted = function() {
  this.setSubmitted(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.hasSubmitted = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional google.protobuf.Timestamp received = 3;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.getReceived = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 3));
};


/** @param {?proto.google.protobuf.Timestamp|undefined} value */
proto.airmap.Traffic.Update.FromProvider.prototype.setReceived = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.airmap.Traffic.Update.FromProvider.prototype.clearReceived = function() {
  this.setReceived(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Update.FromProvider.prototype.hasReceived = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Update.ToProvider = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Update.ToProvider, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Update.ToProvider.displayName = 'proto.airmap.Traffic.Update.ToProvider';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Update.ToProvider.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Update.ToProvider.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Update.ToProvider} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.ToProvider.toObject = function(includeInstance, msg) {
  var f, obj = {
    ack: (f = msg.getAck()) && proto.airmap.Traffic.Update.ToProvider.Ack.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Update.ToProvider}
 */
proto.airmap.Traffic.Update.ToProvider.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Update.ToProvider;
  return proto.airmap.Traffic.Update.ToProvider.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Update.ToProvider} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Update.ToProvider}
 */
proto.airmap.Traffic.Update.ToProvider.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.airmap.Traffic.Update.ToProvider.Ack;
      reader.readMessage(value,proto.airmap.Traffic.Update.ToProvider.Ack.deserializeBinaryFromReader);
      msg.setAck(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Update.ToProvider.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Update.ToProvider.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Update.ToProvider} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.ToProvider.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAck();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.airmap.Traffic.Update.ToProvider.Ack.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.airmap.Traffic.Update.ToProvider.Ack = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.airmap.Traffic.Update.ToProvider.Ack, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.airmap.Traffic.Update.ToProvider.Ack.displayName = 'proto.airmap.Traffic.Update.ToProvider.Ack';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.toObject = function(opt_includeInstance) {
  return proto.airmap.Traffic.Update.ToProvider.Ack.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.airmap.Traffic.Update.ToProvider.Ack} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.ToProvider.Ack.toObject = function(includeInstance, msg) {
  var f, obj = {
    count: jspb.Message.getFieldWithDefault(msg, 1, 0),
    submitted: (f = msg.getSubmitted()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.airmap.Traffic.Update.ToProvider.Ack}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.airmap.Traffic.Update.ToProvider.Ack;
  return proto.airmap.Traffic.Update.ToProvider.Ack.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.airmap.Traffic.Update.ToProvider.Ack} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.airmap.Traffic.Update.ToProvider.Ack}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCount(value);
      break;
    case 2:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setSubmitted(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.airmap.Traffic.Update.ToProvider.Ack.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.airmap.Traffic.Update.ToProvider.Ack} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.airmap.Traffic.Update.ToProvider.Ack.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCount();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getSubmitted();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 count = 1;
 * @return {number}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.getCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.setCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional google.protobuf.Timestamp submitted = 2;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.getSubmitted = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 2));
};


/** @param {?proto.google.protobuf.Timestamp|undefined} value */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.setSubmitted = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.airmap.Traffic.Update.ToProvider.Ack.prototype.clearSubmitted = function() {
  this.setSubmitted(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Update.ToProvider.Ack.prototype.hasSubmitted = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional Ack ack = 1;
 * @return {?proto.airmap.Traffic.Update.ToProvider.Ack}
 */
proto.airmap.Traffic.Update.ToProvider.prototype.getAck = function() {
  return /** @type{?proto.airmap.Traffic.Update.ToProvider.Ack} */ (
    jspb.Message.getWrapperField(this, proto.airmap.Traffic.Update.ToProvider.Ack, 1));
};


/** @param {?proto.airmap.Traffic.Update.ToProvider.Ack|undefined} value */
proto.airmap.Traffic.Update.ToProvider.prototype.setAck = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.airmap.Traffic.Update.ToProvider.prototype.clearAck = function() {
  this.setAck(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.airmap.Traffic.Update.ToProvider.prototype.hasAck = function() {
  return jspb.Message.getField(this, 1) != null;
};


goog.object.extend(exports, proto.airmap);
