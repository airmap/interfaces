syntax = "proto3";

package grpc;

import "ids.proto";
import "google/protobuf/timestamp.proto";

// TODO replace with real geo
message FlightGeometry {
  string geo_json = 1;
}

message Timestamp {
  string RFC3339 = 1;
}

message RulesetId {
  string as_string = 1;
}

message RuleId {
  uint64 as_uint64 = 1;
}

message Assessment {
  enum Code {
    unknown            = 0;  // dark red
    no_fly             = 1;  // red
    action_required    = 2;  // orange
    attention_required = 3;  // yellow
    fly                = 4;  // green
  }

  Code code = 1;
}

message Ruleset {
  message Rule {
    RuleId id                           = 1;  // The unique id of the rule
    string summary                      = 2;  // The AirMap summary of the rule.
    string text                         = 3;  // The full text of the rule
    repeated string airspace_categories = 4;  // The cateogries of airspace this rule references
    Assessment consequence              = 5;  // What a conflict with this rule means to a flight plan's assessment
  }

  // Type enumerates all known types for a Ruleet.
  enum Type {
    unknown_type = 0;
    required     = 1;  // Satisfying the Ruleset is required.
    pickone      = 2;  // One rule from the overall set needs to be picked.
    optional     = 3;  // Satisfying the Ruleset is not required.
  }

  message Header {
    RulesetId id                        = 1;  // The unique id.
    Type type                           = 2;  // The type.
    string name                         = 3;  // The human-readable name.
    string short_name                   = 4;  // The human-readable short name.
    string description                  = 5;  // The human readable description
    bool is_default                     = 6;
    repeated string airspace_categories = 7;  // All airspace categories used by this ruleset
  }

  Header header       = 1;  // The ruleset header
  repeated Rule rules = 2;  // The individual rules in the set.
}

// RulesAssessment is a contextual flightplan assessment against a set of rules
message RulesAssessment {
  enum Status {
    unknown_status  = 0;
    conflicting     = 1;
    not_conflicting = 2;
    missing_info    = 3;
  }

  message Feature {
    enum Type {
      unknown_type   = 0;
      boolean        = 1;
      floating_point = 2;
      string         = 3;
    }
    enum Measurement {
      unknown_measurement = 0;
      speed               = 1;
      weight              = 2;
      distance            = 3;
      sound               = 4;
    }
    enum Unit {
      unknown_unit   = 0;
      kilograms      = 1;
      meters         = 2;
      meters_per_sec = 3;
    }

    string id               = 1;  // The feature ID
    Type type               = 2;
    Measurement measurement = 3;
    Unit unit               = 4;

    Assessment assessment     = 5;  // What this feature means to the flight plan assessments
    string query_text         = 6;  // How to ask the user for the value
    repeated string conflicts = 7;  // How to inform the user on conflicts, only if status is conflicting
    repeated RuleId rules     = 8;  // Relevant rules which depend on this feature
  }

  message Advisory {
    RuleId rule           = 1;  // The unique id of the rule
    Status status         = 2;  // The status of the rule.
    string summary        = 3;  // The AirMap summary of the rule.
    string text           = 4;  // The full text of the rule.
    RulesetId ruleset     = 5;  // The rule set this rule is part of
    Assessment assessment = 7;  // The assessment of this rules

    message Airspace {
      string name                               = 1;  // The name of the airspace
      AirspaceId id                             = 2;  // The unique id of the airspace
      string category                           = 3;  // The human-readable category of the airspace
      string phone_number                       = 5;
      string url                                = 6;
      google.protobuf.Timestamp effective_start = 7;
      google.protobuf.Timestamp effective_end   = 8;
    }
    repeated Airspace airspaces = 8;  // Contains intersecting airspaces for spatial rules
  }

  // Authority models an authority capable of authorizing flight plans.
  message Authority {
    AuthorizerId id = 1;  // The id of the authorizer (aka connector)
    string name     = 2;  // The name of the authority's entity.
  }

  // Authorization bundles up the authorization status of a flight plan.
  message Authorization {
    // Status enumerates all known states of an Authorization.
    enum Status {
      unknown                  = 0;  // The status is unknown.
      accepted                 = 1;  // The flight plan is accepted.
      rejected                 = 2;  // The flight plan is rejected.
      pending                  = 3;  // The request for authorization is pending a response.
      accepted_upon_submission = 4;  // The request will be accepted upon submission.
      rejected_upon_submission = 5;  // The request will be rejected upon submission.
      pending_upon_submission  = 6;  // The request will be pending upon submission
    }

    Status status         = 1;  // The overall status of the request.
    Authority authority   = 2;  // The authority that handles the request.
    string description    = 3;  // The human-readable description of this authorization
    string message        = 4;  // The human-readable message provided by the authority.
    repeated RuleId rules = 5;  // Relevant rules which depend on this authorization
  }

  Assessment assessment                 = 1;  // The overall assessment of the flight plan
  Timestamp created_at                  = 2;  // Point in time when this advisory was calculated
  repeated Feature features             = 3;  // all relevant features
  repeated Advisory advisories          = 4;  // all relevant advisories
  repeated Authorization authorizations = 5;  // All relevant Authorizations
}

message FindRulesetsQuery {
  FlightGeometry geometry = 1;
}
message FindRulesetsResponse {
  repeated Ruleset.Header rulesets = 1;
}

service Rules {
  rpc GetRuleset(RulesetId) returns (Ruleset);
  rpc FindRulesets(FindRulesetsQuery) returns (FindRulesetsResponse);
}
